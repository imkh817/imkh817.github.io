---
title: Stream
date: 2025-06-28 23:45:21 +0900
categories: [JAVA]
tags: [stream, java]     # TAG 이름은 항상 소문자여야 합니다.
---

## 배경 : Stream은 왜 탄생했을까?

---

💡 **Stream API란?**

> **Stream은 데이터의 흐름(데이터 파이프라인)을 선언적으로 처리하는 API다**
>
- `Collection`에 저장된 데이터에 대해
- 반복, 필터링, 매핑, 집계 등을
- 함수형 프로그래밍 방식으로 처리

💡 **전통적인 컬렉션처리 vs Stream API**

Java 8이전에는 반복문 또는 `Iterator`를 통해 데이터를 처리했음

```java
List<User> users = ...;
List<String> names = new ArrayList<>();

for (User user : users) {
    if (user.getAge() >= 30) {
        names.add(user.getName());
    }
}
```

**😮‍💨 문제점**

1. 반복문 + 조건문  + 수집 코드가 뒤섞여 있음

   → “무엇을” 하는지가 “어떻게” 구현됐는지에 묻힘

2. 병렬 처리가 어렵고, 가독성이 떨어짐

   → 10줄 이상 걸리는 것도 많음

3. 중간 가공을 추상화하기 힘듦

   → 메서드 체이닝이 안되니 재사용 어렵고 유지보수도 번거로움


## Stream 방식의 변화

---

```java
List<String> names = users.stream()
		.filter(user -> user.getAge() >= 30) // 조건 필터
		.map(User::getName)                  // 가공
		.collect(Collectors.toList());       // 수집
```

**✅ 장점**

- “무엇을 할지”에 집중 (어떻게는 stream이 처리함)
- 중간 가공 단게를 연속적으로 조립 가능
- 3~4줄에 전체흐름이 요약됨
- `.parallelStream()`으로 쉽게 병렬화 가능
- 불변성 보장
  - 원본 데이터를 변경하지 않고 새 컬렉션 생성
- 지연평가 지원

## 지연평가 (Lazy Evaluation)

---

🤔 **지연평가란?**

- 지연평가란 스트림의 요소에 대한 여산이 **실제로 필요할 때만 수행되는 방식**을 의미한다. 보통 이는 최종 연산(Terminal Operaiton)이 호출되는 시점에 발생한다. 이는 연산이 곧바로 수행되는 즉시 평가(Eager Evaluation)과는 대조적인 개념이다.
- Java 스트림에서는 중간연산이 최종연산이 호출되기전까지 실행되지 않는다. 이러한 방식은 반복 횟수와 계산량을 줄일 수 있기 때문에, 특히 대용량 데이터셋을 처리할 때 성능을 최적화하는 데 효과적이다.

### 원리

**1️⃣ 스트림 초기화**

- `stream()`과 같이 컬렉션에서 스트림을 생성하면, JVM은 스트림의 초기 수정을 설정한다. 이 때 스트림은 소스 데이터(예: 컬렉션이나 배열)에 대한 참조를 저장한다.

**2️⃣ 중간연산**

- `filter`, `map`등의 중간 연산을 체이닝하면, JVM은 각각의 연산에 대해 새로운 스트림 객체를 생성하여 이전 스트림과 연결한다. 하지만 이 단계에서는 실제 계산이 전혀 이루어지지 않는다.
- 즉 연산을 “등록”만 할 뿐, 실행은 미뤄둔다.

**3️⃣ 최종 연산 실행**

- 지연 평가는 최종 연산이 호출될 때 비로소 작동한다.
- JVM은 소스부터 최종 연산까지 파이프라인을 따라 연산들을 적용하며 전체 스트림 처리를 시작한다.

**4️⃣ 요소 처리 방식**

- JVM은 성능과 메모리 사용을 최적화하기 위해 데이터를 한 요소씩 가져와 처리한다.
- 이 방식은 특히 큰 컬렉션을 다룰 때 불필요한 데이터를 메모리에 올리지 않아도 되므로 효율적이다.

5️⃣ **단락(short-circuit) 연산 지원**

- findFirst, limit과 같이 “조건을 만족하면 즉시 처리를 멈추는 연산(단락 연산)”의 경우, JVM은 조건이 충족되면 더 이상 데이터를 처리하지 않는다.
- 이 덕분에 불필요한 계산을 줄일 수 있다.
