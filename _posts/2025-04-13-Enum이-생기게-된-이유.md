# Enum 🧾

## Enum이 생겨난 이유
먼저 Enum이 뭔지 알아보기 전에, Enum이 왜 생겨났고 왜 사용하는지 아래의 예제를 통해 알아보자.

## 요구사항
사용자는 다양한 결제 수단을 선택할 수 있으며, 결제 방식에 따라 서로 다른 전략이 실행된다.
현재 제공되는 결제 수단은 다음과 같다:
- kakao : 카카오페이를 통해 결제
- naver : 네이버페이를 통해 결제
- bad : 불안정한 테스트용 결제 수단
결제 수단을 입력하면, 해당 방식에 맞는 결제 전략 객체를 생성해야 한다.
- 정의되지 않은 결제 수단을 입력할 경우 예외를 발생시킨다.

## 문자열1
사용자가 선택한 결제 수단에 따라 결제 수단을 제공하는 클래스를 만들어보자.
```java
public class StrategyFactory {
    public static PayStrategy of(String payOption, int amount){
        if("kakao".equals(payOption)){
            return new KakaoStrategy(payOption, amount);
        } else if("naver".equals(payOption)){
            return new NaverStrategy(payOption, amount);
        } else if("bad".equals(payOption)){
            return new BadStrategy(payOption, amount);
        } else {
            throw new IllegalArgumentException("해당 전략이 없습니다.");
        }
    }
}
```

### 단점
지금과 같이 단순히 문자열을 입력하는 방식은, 오타가 발생하기 쉽다. 
그리고 KAKAO, kakao 등 다양한 형식으로 문자열을 입력할 수 있어 일관성이 떨어지게 된다. 또한 값을 잘못 입력하였다고 하더라도
컴파일 시 감지되는 것이 아닌 런타임에서먼 문제가 발생하기 떄문에 디버깅이 어려워질 수 있다.

## 문자열2
문자열1의 단점을 해결하려면 특점 범위로 값을 제한해야 한다. 예를 들어, kakao, naver, bad라는 정확한 문자만 of() 메서드에 전달되어야 한다.
하지만 String은 어떤 문자열이든 받을 수 있기 때문에 자바 문법 관점에서는 아무런 문제가 없다. 결국 String 타입을 사용해서는 문제를 해결할 수 없다.

이번에는 대안으로 문자열 상수를 사용해보자. 상수는 미리 정의한 변수명을 사용할 수 있기 때문에 문자열을 직접 사용하는 것 보다 안전하다.

```java
public class PayOption {
    public static final String KAKAO = "KAKAO";
    public static final String NAVER = "NAVER";
    public static final String BAD = "BAD";
}

```

```java
public class StrategyFactory {
    public static PayStrategy of(String payOption, int amount){
        if(PayOption.KAKAO.equals(payOption)){
            return new KakaoStrategy(payOption, amount);
        } else if(PayOption.NAVER.equals(payOption)){
            return new NaverStrategy(payOption, amount);
        } else if(PayOption.BAD.equals(payOption)){
            return new BadStrategy(payOption, amount);
        } else {
            throw new IllegalArgumentException("해당 전략이 없습니다.");
        }
    }
}
```

문자열 상수를 사용한 덕분에 전체적으로 코드가 더 명확해졌다. 그리고 of()에 인자를 전달할 때도 PayOption 클래스가 제공하는 문자열 상수를 사용하면 된다.
더 좋은 점은 만약 실수로 상수의 이름을 잘못 입력하면 컴파일 시점에 오류가 발생한다는 점이다. 따라서 오류를 쉽고 빠르게 찾을 수 있다.

### 단점
문자열 상수를 사용해도, 지금까지 발생한 문제들을 근본적으로 해결할 수 는 없다. 왜냐하면 String 타입은 어떤 문자열이든 입력할 수 있기 때문이다.
어떤 개발자가 실수로 PayOption에 있는 문자열 상수를 사용하지 않고 직접 문자열을 사용해도 막을 수 있는 방법이 없다.
또한, of() 함수를 사용하는 입장에서는 문자열 상수가 어디에 있는지 알 수가 없다. 왜냐하면 of() 함수를 보면 String은 다 입력 할 수 있다고 되어있기 떄문이다.
결국 누군가 주석을 잘 남겨두어서, PayOption에 있는 상수를 사용해달라고 하여야 한다.

```java
public class StrategyFactory {
    public static PayStrategy of(String payOption, int amount){ // String을 매개변수로 받기 떄문에 해당 코드를 사용하는 입장에선 확인할 수 없다.
        if(PayOption.KAKAO.equals(payOption)){
            return new KakaoStrategy(payOption, amount);
        } else if(PayOption.NAVER.equals(payOption)){
            return new NaverStrategy(payOption, amount);
        } else if("bad".equals(payOption)){ // 문자열 상수를 사용하지 않고, 직접 문자열을 사용해도 컴파일 오류 X
            return new BadStrategy(payOption, amount);
        } else {
            throw new IllegalArgumentException("해당 전략이 없습니다.");
        }
    }
}
```

## 타입 안전 열거형 패턴
지금까지 설명한 문제를 해결하기 위해 많은 고민 끝에 나온 것이 타입 안전 열겨형 패턴이다.
타입 안전 열거형 패턴을 사용하면 나열한 항목만 사용할 수 있다는 것이 핵심이다. 나열한 항목이 아닌 것은 사용할 수 없다.
즉, 내가 나열한 KAKAO, NAVER, BAD만 안전하게 사용할 수 있다.
해당 패턴을 직접 구현해보자.

```java
public class PayOption {
    private PayOption(){}
    public static final PayOption KAKAO = new PayOption();
    public static final PayOption NAVER = new PayOption();
    public static final PayOption BAD = new PayOption();
}

```

```java
public class StrategyFactory {
    public static PayStrategy of(PayOption payOption, int amount){
        if(payOption == PayOption.KAKAO){
            return new KakaoStrategy(payOption, amount);
        } else if(payOption == PayOption.NAVER){
            return new NaverStrategy(payOption, amount);
        } else if(payOption == PayOption.BAD){
            return new BadStrategy(payOption, amount);
        } else {
            throw new IllegalArgumentException("해당 전략이 없습니다.");
        }
    }
}
```
of() 메서드는 매개변수로 PayOption 클래스를 사용한다. 값을 비교할때는 payOption == PayOption.KAKAO와 같이 == 참조값 비교를 사용하면 된다.
이제 PayOption 인스턴스를 사용할 떄는 PayOption 내부에서 정의한 상수를 사용해야 한다. 그렇지 않으면 컴파일 오류가 발생한다.

### 장점
1. 정해진 객체만 사용할 수 있기 때문에, 잘못된 값을 입력하는 문제를 근본적으로 방지할 수 있다.
2. 정해진 객체만 사용하므로 데이터의 일관성이 보장된다.

### 단점
이 패턴을 구현하려면 다음과 같이 많은 코드를 작성해야 한다. 그리고 외부에서 인스턴스를 생성하지 못하게 private 생성자를 추가하는 등 유의해야 하는 부분도 있다.

## 열거형 - Enum Type
자바는 타입 안전 열거형 패턴을 매우 편리하게 사용할 수 있는 열거형(Enum Type)을 제공한다.

```java
public enum PayOptions {
    KAKAO, NAVER, BAD
}
```

앞에서 쓴 직접 `PayOption`를 구현할 때와는 비교가 되지 않을 정도로 편리하다. 

