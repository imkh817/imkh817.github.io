---
title: LAN 너머의 세계, 통신을 위한 기반 (네트워크 계층) ✈️
date: 2025-03-18 21:46:21 +0900
categories: [Network]
tags: [Network]     # TAG 이름은 항상 소문자여야 합니다.
---
## 물리, 데이터 링크 계층의 한계
네트워크 통신의 가장 기본적인 단위인 LAN을 살펴보면, 데이터 전송의 초기 단계는 물리 계층과 데이터 링크 계층이 담당한다.<br>
이 두 계층은 LAN 내에서의 효율적인 통신을 위해 설계되었지만, 처음부터 LAN을 넘어선 다른 네트워크와 통신을 하기 위해서 만들어지지 않았다.

### 물리 계층의 한계 : "연결" 그 이상의 의미를 담지 못한다.
물리 계층은 전기 신호, 광 신호, 전파 등 물리적인 매체를 통해 데이터를 전송하는 가장 기본적인 역할을 수행한다.<br>
하지만 물리 계층은 단순히 "연결"을 제공할 뿐, 데이터가 누구에게, 어디로 향해야 하는지에 대한 정보를 알지 못한다.

### 데이터 링크 계층의 한계 : "MAC 주소" 라는 좁은 세상
데이터 링크 계층은 물리 계층을 통해 전송되는 비트열을 프레임이라는 단위로 묶고, 오류 제어, 흐름 제어, 매체 접근 제어 등의 기능을 제공하여 LAN 내에서의 안정적인 데이터 전송을 보장한다.
**특히 MAC 주소라는 고유한 식별자를 사용하여 LAN 내의 장치를 구분하고 데이터를 전달한다. 하지만 MAC 주소는 LAN 이라는 지역에서만 통용되는 지역 번호와 같다.**

---
## 네트워크 계층의 핵심, 인터넷 프로토콜(IP)
IP는 인터넷 프로토콜은 현대 인터넷의 근간을 이루는 핵심적인 프로토콜이다. IP는 서로 다른 네트워크 간의 통신을 가능하게 하며, 데이터를 정확한 목적지까지 전달하는 데 필요한 다양한 기능을 제공한다.
그 중에서 가장 중요한 두 가지 공식 기능은 **주소 지정** 과 **단편화**이다.

### 주소지정 (IP addressing)
#### 역할
- IP 주소 지정은 **네트워크에 연결된 모든 장치에게 고유한 식별자를 부여하는 기능이다.**
- IP 주소의 계층 구조
  - IP 주소는 네트워크 ID와 호스트 ID로 구성된 계층 구조를 가진다. 네트워크 ID는 장치가 속한 네트워크를 식별하고, 호스트 ID는 해당 네트워크 내에서 장치를 식별한다.
    이러한 계층 구조는 라우터가 효율적으로 경로를 설정하고 패킷을 전달할 수 있도록 돕는다.
- IP 주소 지정 방식
  - 수동할당 : 네트워크 관리자가 각 장치에 IP 주소를 직접 할당하는 방식이다. IP 주소가 고정되어야 하는 서버와 같은 장치에 주로 사용된다.
  - 자동할당 : [DHCP]({%post_url 2025-03-19-DHCP%})(Dynamic Host Configuration Protocol) 서버를 사용하여 장치에 IP 주소를 자동으로 할당하는 방식이다.
             IP 주소 관리를 간소화하고, IP 주소 충돌을 방지할 수 있다.

### 단편화 (IP fragmentation)
#### 역할
- 단편화는 IP 패킷의 크기가 네트워크의 최대 전송 단위(MTU, Maximum Transmission Unit)보다 클 때, **패킷을 더 작은 조각으로 나누는 기능이다.**
- MTU 크기 이하로 **나누어진 패킷은 수신지에 도착하면 다시 재조합한다.**

#### MTU(Maximum Transmission Unit)
- MTU는 네트워크 링크에서 **한 번에 전송할 수 있는 IP 패킷의 최대 크기**를 의미한다.
- 단편화 예시
  - 4000바이트의 패킷을 전송하려고 하는데 MTU가 1500이다.
  - 패킷은 아래와 같이 분할된다.
  ![IP 단편화 예시](/assets/img/IP%20단편화.png)
  - 해설
   - 패킷이 4000바이트라면 페이로드 3980바이트, 헤더 20바이트이다.
   - 각 단편화는 모두 헤더를 가져야 하므로 최대 1480바이트로 분할될 수 있다.
   - 즉 1480,1480,1020으로 분할된다.
   - 첫번째, 두번째 단편은 뒤에 이어질 단편이 있으므로 more flag가 1이다.
   - offset은 8바이트 단위로 표시된다. 1480/8 = 185, 2960/8 = 370
     - offset은 초기 데이터에서 몇 번째로 떨어진 패킷인지를 나타낸다.
     - 수신지는 패킷을 재조합할때 offset을 보고 해당 패킷이 초기 데이터에서 몇 번째에 해당하는 패킷인지를 확인한다.
   - [참고](https://itwiki.kr/w/IP_%EB%8B%A8%ED%8E%B8%ED%99%94)

#### 단편화는 많이 수행되는 것이 과연 좋을까?
- IP 단편화는 되도록 하지 않는 것이 좋다.
- 불필요한 트래픽 증가와 대역폭을 낭비하게 된다.
- 쪼개진 IP 패킷들을 하나로 합치는 과정에 발생하는 부하도 성능 저하의 요인이 된다.
- 그래서 오늘날 해당 단점으로 인해 DF(Don't Fragment) 비트가 세팅되어 있어, 단편화를 진행하지 않는다.
     
---
## IP 주소만으로는 충분하지 않다 (ARP 프토로콜)
IP 주소를 통해 패킷을 목적지까지 보낼 수 있게 되었지만, 문제가 하나 남아있다. **네트워크 계층에서 목적지의 IP 주소를 알고 있어도,
실제 데이터를 전송하려면 MAC 주소를 알아야한다.** 즉 같은 네트워크(LAN) 내에서 데이터를 전달할 대상의 물리적 주소를 찾아야한다.
이 때 사용하는 프로토콜이 `ARP(Address Resolution Protocol)` 이다.

### 상황으로 알아보기
- A LAN(192.168.1.0/24)에는 a-1(192.168.1.10) 컴퓨터가 있음
- B LAN(192.168.2.0/24)에는 b-1(192.168.2.20) 컴퓨터가 있음
- a-1 컴퓨터가 b-1 컴퓨터에게 데이터를 보내려고 하는 상황

#### 문제점 ⚠️
- a-1은 b-1의 IP 주소(192.168.2.20)을 알고있지만, 해당 b-1 컴퓨터의 MAC 주소는 알 수 없음
- 이유 : a-1과 b-1은 서로 다른 네트워크에 있기 때문에 브로드캐스트가 전달되지 않음.

#### ARP 동작 과정
- a-1에서 송신
1. a-1(192.168.1.10)은 b-1(192.168.2.20)에게 패킷을 보내야 하지만, MAC 주소를 모름
2. a-1은 자신의 라우터(게이트웨이)의 IP 주소를 확인(예:192.168.1.1)를 확인
3. a-1은 라우터의 MAC주소를 알아야하므로 이떄 ARP 요청을 보냄(브로드캐스트) -> "192.168.1.1의 MAC 주소가 뭐야?"
4. 라우터(게이트웨이)가 자신의 MAC 주소를 a-1에게 응답(유니캐스트)
5. 이제 a-1은 b-1로 가는 패킷의 라우터의 MAC 주소를 이용해 전송
6. 라우터는 패킷을 받아서 B LAN으로 전달

- b-1에서 수신
1. B LAN에서 패킷을 받은 라우터는 b-1의 MAC 주소를 알아야 하므로 이때 APR 요청을 보냄(브로드 캐스트) -> "192.168.2.20의 MAC 주소가 뭐야?"
2. b-1이 자신의 MAC 주소를 응답(유니캐스트)
3. 라우터는 b-1의 MAC 주소를 이용해 패킷을  b-1에게 전달

- ARP 캐시 테이블
  - a-1 호스트와 b-1 호스트는 네트워크 부하를 줄이기 위해 **조회한 MAC 주소를 일정 시간 동안 저장**하고, 이 후에는 APR 통신 없이 데이터를 전송할 수 있다.
  - ARP 테이블을 확인하는 명령어:
    ```
    arp -a
    
    // 결과
    ? (192.168.0.1) at 58:86:94:9b:70:24 on en0 ifscope [ethernet]
    ? (192.168.0.2) at da:45:45:7d:85:e7 on en0 ifscope [ethernet]
    ? (192.168.0.10) at 9e:74:c2:e4:cc:35 on en0 ifscope [ethernet]
    mdns.mcast.net (224.0.0.251) at 1:0:5e:0:0:fb on en0 ifscope permanent [ethernet]
    ```
    
---

## IP 주소 구조
IP 주소는 크게 **네트워크 주소**와 **호스트 주소**로 구성된다.
- 네트워크 주소
  - 네트워크를 표현하는 부분
  - 호스트가 속한 특정 네트워크를 식별
- 호스트 주소
  - 호스트를 표현하는 부분
  - 특정 호스트를 식별
- 예시 : 192.168.0.1 (서브넷 마스크가 `255.255.255.0`을 가정)
  - `192.168.0` -> 네트워크 주소
  - `1` -> 호스트 주소

그럼 네트워크 주소와 호스트 주소는 어떤 비율로 해야 좋은걸까?<br>
이런 고민을 해결하기 위해 생겨난 개념이 IP 주소의 **클래스(class)** 이다.

### 클래스(class), 클래스 풀 주소 체계(classful addressing)
- 클래스 : 네트워크 크기에 따라 IP 주소를 분류하는 기준이다.
- 클래스 풀 주소 체계 : 클래스를 기반으로 IP 주소를 관리하는 주소 체계
- 필요한 호스트 IP 개수에 따라 클래스를 달리 선택한다. 즉, 네트워크 크기를 조절할 수 있다.

![클래스 풀 주소 체계](/assets/img/클래스%20풀%20주소%20체계.png)

#### 클래스 풀 주소 체계 단점
- 클래스별 네트워크 크기가 고정되어 있어 여전히 **낭비되는 IP 주소가 많다.**
- 해당 단점을 보완하기 위해 클래스리스 주소 체계를 사용하며, 오늘날 주로 활용되는 방식이다.

### 클래스리스 주소 체계(classless addressing)
- **클래스 개념 없이 클래스에 구애받지 않고 네트워크 영역을 나누고 호스트에게 IP 주소 공간을 할당하는 방식**
- 클래스풀 주소 체계보다 **더 유동적이고 정교한 네트워크 구획이 가능하다.**
- 오늘날 주로 사용되는 방식이다.

#### 서브넷 마스크(subnet mask)
- **클래스 없이 IP 주소의 네트워크, 호스트 주소를 구분하는 수단**
- IP 주소상에서 네트워크 주소는 1, 호스트 주소는 0으로 표기한 비트열이다.
- 서브넷 마스크는 `255.255.255.0` 같은 형식으로 표현된다.
- **255가 있는 부분**이 네트워크 주소를 나타내고,
- **0이 있는 부분**이 호스트 주소를 나타낸다.
- 예를 들어, IP 주소 `192.168.1.1`과 서브넷 마스크 `255.255.255.0`이 있다면,
  - **네트워크 주소**: `192.168.1.0`
  - **호스트 주소**: `1` (즉, 1~254까지의 값 사용 가능)
- 서브넷 마스크 확인하는 명령어:
    ```
    networksetup -getinfo Wi-Fi
    
    // 결과
    DHCP Configuration
    IP address: 192.168.0.3 // 아이피 주소 (사설 아이피)
    Subnet mask: 255.255.255.0 // 서브넷 마스크
    Router: 192.168.0.1 라우터 // 현재 맥북이 사용하고 있는 네트워크 게이트웨이 IP주소
    Client ID: 
    IPv6: Automatic
    IPv6 IP address: none
    IPv6 Router: none
    Wi-Fi ID: 84:94:37:e8:a8:63 // 현재 맥북이 연결되어 있는 Wi-Fi 공유기의 MAC 주소
    ```
  
#### 서브넷 마스크 표기법 CIDR
서브넷 마스크는 **CIDR(Classless Inter-Domain Routing) 표기법**으로도 표현할 수 있다.

- `255.255.255.0` → `/24`
- `255.255.0.0` → `/16`
- `255.0.0.0` → `/8`

예를 들어, `192.168.1.0/24`는 **서브넷 마스크가 `255.255.255.0`인 네트워크**를 의미한다.
### 호스트의 주소 공간을 모두 사용할 수 있는건 아니다
- **호스트 주소가 전부 0인 IP 주소는 해당 네트워크 자체를 의미하는 네트워크 주소로 사용된다.**
- **호스트 주소가 전부 1인 IP 주소는 브로드캐스트 주소로 사용된다.**

---

## 공인 IP와 사설 IP

###  공인 IP (Public IP)

- 인터넷에 직접 연결되는 **전 세계에서 유일한 IP 주소**
- ISP(인터넷 서비스 제공업체)에서 할당해줌
- 예) `211.45.67.89`, `8.8.8.8` (구글 DNS)

### 사설 IP (Private IP)

- 내부 네트워크(회사, 가정 등)에서만 사용되는 IP
- 인터넷에서는 직접 사용 불가능 (NAT를 통해 공인 IP로 변환해야 함)
- 사설 IP 대역
  - `10.0.0.0 ~ 10.255.255.255`
  - `172.16.0.0 ~ 172.31.255.255`
  - `192.168.0.0 ~ 192.168.255.255`
- 예) `192.168.1.100`, `10.0.0.50`

### 사설 IP 주소를 사용하는 호스트는 외부 네트워크와 어떻게 통신할까?
#### NAT(Network Address Translation)
- **IP 주소 변환 기술이다.** 사설 IP와 공인 IP 주소를 변환하는데 사용한다.
- 대부분의 **라우터와 공유기가 NAT 기능을 내장하고 있다.**
  - 사설 네트워크의 패킷 속 사설 IP 주소는 공유기를 거쳐 공인 IP 주소로 변경
  - 외부 네트워크의 패킷 속 공인 IP 주소는 공유기를 거쳐 사설 IP 주소로 변경
- NAT를 통해 사설 IP 주소를 사용하는 여러 호스트는 적은 수의 공인 IP 주소를 공유 가능하다.

---

## 게이트웨이
게이트웨이(Gateway)는 **다른 네트워크와 통신할 때 거치는 출입구 역할**을 하는 네트워크 장비이다.

- 게이트웨이의 일반적인 의미
  - 서로 다른 네트워크를 연결하는 하드웨어적/소프트웨어적 수단
- 호스트가 속한 네트워크 외부로 나가기 위한 기본적인 첫 경로(첫번째 홉)이다.
  - 네트워크 외부와 연결된 라우터(공유기)의 주소를 의미하는 경우가 많다.
- **같은 네트워크 내에서는 게이트웨이 없이 직접 통신이 가능하다.**
- 다른 네트워크로 데이터를 보내려면 **게이트웨이(보통 라우터)를 통해야 한다.**
- 예) `192.168.1.1` (공유기의 기본 게이트웨이)

---

## 라우터

### 역할
1. 패킷 포워딩
   - 라우터의 가장 중요한 역할은 네트워크를 통해 들어온 데이터 패킷을 목적지 주소에 따라 가장 적절한 경로로 전달하는 것이다.
2. 경로 설정
   - 라우터는 목적지까지의 최적 경로를 결정하기 위해 라우팅 테이블이라는 정보를 사용한다.
   - 라우팅 테이블은 네트워크 토폴로지, 네트워크 혼잡도, 거리 등의 정보를 기반으로 생성되며, 라우터는 테이블을 참조하여 패킷을 어느 방향으로 보낼지 결정한다.
3. 네트워크 분리 (물리적)
   - 라우터는 서로 다른 네트워크를 분리하고 연결하는 역할을 한다.
   - 네트워크를 분리한다는건 물리적 분리를 의미한다. 논리적으로 네트워크를 분리하는건 데이터 링크 계층에서 스위치의 VLAN 기능을 사용한다.
4. 보안
   - 라우터는 방화벽 기능을 제공하여 네트워크를 외부의 위험으로부터 보호할 수 있다.

### 라우터 작동 원리
1. 패킷 수신 
   - 네트워크 인터페이스를 통해 패킷을 받는다.
2. 주소 확인
   - 패킷 헤더에서 목적지 IP 주소를 확인한다.
3. 라우팅 테이블 참조
   - 라우팅 테이블에서 해당 IP 주소에 대한 최적 경로를 찾는다.
4. 패킷 포워딩
   - 라우팅 테이블에 따라 패킷을 다음 홉(다른 라우터)로 전달한다.
5. TTL 감소
   - 패킷이 라우터를 통과할 때마다 TTL(Time To Live) 값이 감소한다.
   - TTL 값이 0이 되면 패킷은 폐기되어 네트워크 루프를 방지한다.

### 라우팅 과정(홉 수) 확인
```
traceroute www.goolge.com 입력 
    
traceroute to www.goolge.com (142.250.76.131), 64 hops max, 40 byte packets
 1  192.168.0.1 (192.168.0.1)  4.593 ms  2.707 ms  2.611 ms
 2  59.6.97.254 (59.6.97.254)  4.410 ms  4.274 ms *
 3  112.188.47.137 (112.188.47.137)  4.643 ms  5.056 ms  3.940 ms
 4  112.188.44.41 (112.188.44.41)  5.178 ms
    112.188.32.229 (112.188.32.229)  5.024 ms
    112.188.44.157 (112.188.44.157)  4.971 ms
 5  112.174.49.81 (112.174.49.81)  10.563 ms
    112.174.47.81 (112.174.47.81)  11.769 ms  12.032 ms
 6  112.174.84.26 (112.174.84.26)  11.634 ms  10.146 ms
    112.174.84.22 (112.174.84.22)  11.819 ms
 7  72.14.202.136 (72.14.202.136)  33.314 ms
    142.250.165.78 (142.250.165.78)  32.718 ms  33.012 ms
 8  192.178.108.209 (192.178.108.209)  32.161 ms  31.968 ms *
 9  142.250.239.221 (142.250.239.221)  31.767 ms  30.928 ms  32.174 ms
10  108.170.248.194 (108.170.248.194)  38.432 ms
    108.170.248.190 (108.170.248.190)  37.315 ms
    kix07s06-in-f3.1e100.net (142.250.76.131)  31.705 ms
```
- 10개의 홉을 거쳐 108.170.248.194(구글)에 도착
- 1번은 내 게이트웨이 주소인데 생각해보면 일반적인 환경에선 무조건 첫번째 홉은 내 게이트 웨이 주소일수밖에 없다.

### 라우팅 테이블
#### 라우팅 테이블에 포함된 정보
1. 수신지 IP 주소와 서브넷 마스크
   - 최종적으로 패킷을 전달할 대상
2. 다음 홉(next hop)
   - 최종 수신지까지 가기 위해 다음으로 거쳐야 할 호스트의 IP 주소나 인터페이스
   - 게이트웨이라고 명시되기도 한다.
3. 네트워크 인터페이스
   - 패킷을 내보낼 통로
   - 인터페이스(NIC) 이름이 직접 명시되거나 인터페이스에 대응하는 IP 주소 명시
4. 메트릭(metric)
   - 해당 경로로 이동하는 데에 드는 비용
   - 라우팅 테이블의 여러 경로 중 메트릭이 낮은 경로를 선호
   
```
netstat -nr -f inet 입력

Routing tables

Internet:
Destination        Gateway            Flags               Netif Expire
// default 라우트는 라우팅 테이블에 경로가 없을때 사용한다.
// 기본적으로 패킷을 내보낼 경로를 의미하며, 모든 IP 주소를 의미하는 0.0.0.0/0으로 명시된다.
// 예시 : 수신지 IP 주소가 1.2.3.4인 패킷을 받았을 때 en0 네트워크 인터페이스를 통해 192.168.0.1로 패킷을 전송한다.
default            192.168.0.1        UGScg                 en0       
127                127.0.0.1          UCS                   lo0       
127.0.0.1          127.0.0.1          UH                    lo0       
169.254            link#11            UCS                   en0      !
192.168.0          link#11            UCS                   en0      !
192.168.0.1/32     link#11            UCS                   en0      !
192.168.0.1        58:86:94:9b:70:24  UHLWIir               en0   1136
192.168.0.2        da:45:45:7d:85:e7  UHLWIi                en0   1126
192.168.0.3/32     link#11            UCS                   en0      !
224.0.0/4          link#11            UmCS                  en0      !
224.0.0.251        1:0:5e:0:0:fb      UHmLWI                en0       
239.255.255.250    1:0:5e:7f:ff:fa    UHmLWI                en0       
255.255.255.255/32 link#11            UCS                   en0      !
```

